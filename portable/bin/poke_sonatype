#!/usr/bin/env -S python-venv --virtualenv dotfiles
"""Yell at sonatype sometimes"""

import abc
import ast
import dataclasses
import json
import logging
import os
import re
import typing
from xml.etree import ElementTree

import jproperties
import requests
from jmullan.cmd import cmd
from jmullan.logging import easy_logging
from jmullan.logging.helpers import logging_context

logger = logging.getLogger(__name__)

easy_logging.easy_initialize_logging()


T = typing.TypeVar("T")

REPOS = {
    "snapshots": "repositories/snapshots",
    "releases": "repositories/releases",
    "public": "groups/public"
}
POM_NAMESPACE = {"pom": "http://maven.apache.org/POM/4.0.0"}

class UniqueByUrl(abc.ABC):
    @property
    @abc.abstractmethod
    def url(self): ...

    def __eq__(self, other):
        return self.url == other.url

    def __hash__(self):
        return hash(self.url)


@dataclasses.dataclass(frozen=True)
class Repo(UniqueByUrl):
    sonatype_path: str
    subpath: str
    name: str

    def __post_init__(self):
        assert self.sonatype_path is not None
        assert self.subpath is not None
        assert self.name is not None

    @property
    def url(self) -> str:
        return f"{self.sonatype_path}/{self.subpath}"

    def context(self) -> dict[str, typing.Any]:
        return {"nexus_repo": self.name}


@dataclasses.dataclass(frozen=True)
class Group:
    group_id: str

    def __post_init__(self):
        assert self.group_id is not None

    @property
    def group_path(self):
        return self.group_id.replace(".", "/")

    def context(self) -> dict[str, typing.Any]:
        return {"group_id": self.group_id}


@dataclasses.dataclass(frozen=True)
class RepoArtifact(UniqueByUrl):
    nexus_repo: Repo
    group: Group
    artifact_id: str

    def __post_init__(self):
        assert self.nexus_repo is not None
        assert self.group is not None
        assert self.artifact_id is not None

    @property
    def url(self) -> str:
        return f"{self.nexus_repo.url}/{self.group.group_path}/{self.artifact_id}"

    @property
    def metadata_url(self) -> str:
        return f"{self.url}/maven-metadata.xml"

    @property
    def metadata_sha_url(self) -> str:
        return f"{self.metadata_url}.sha1"

    def context(self) -> dict[str, typing.Any]:
        context = self.nexus_repo.context()
        context.update(self.group.context())
        context["artifact_id"] = self.artifact_id
        return context


@dataclasses.dataclass(frozen=True)
class ArtifactVersion(UniqueByUrl):
    repo_artifact: RepoArtifact
    version: str

    def __post_init__(self):
        assert self.repo_artifact is not None
        assert self.version is not None

    @property
    def url(self) -> str:
        return f"{self.repo_artifact.url}/{self.version}"

    @property
    def metadata_url(self) -> str:
        return f"{self.url}/maven-metadata.xml"

    @property
    def metadata_sha_url(self) -> str:
        return f"{self.metadata_url}.sha1"

    @property
    def artifact_id(self):
        return self.repo_artifact.artifact_id

    def context(self) -> dict[str, typing.Any]:
        context = self.repo_artifact.context()
        context["version"] = self.version
        return context


@dataclasses.dataclass(frozen=True)
class ArtifactVersionExtension(UniqueByUrl):
    artifact_version: ArtifactVersion
    extension: str
    sub_version: str

    def __post_init__(self):
        assert self.artifact_version is not None
        assert self.extension is not None
        assert self.sub_version is not None

    @property
    def url(self) -> str:
        return f"{self.artifact_version.url}/{self.artifact_id}-{self.sub_version}.{self.extension}"

    @property
    def sha_url(self) -> str:
        return f"{self.url}.sha1"

    @property
    def artifact_id(self):
        return self.artifact_version.artifact_id

    def context(self) -> dict[str, typing.Any]:
        context = self.artifact_version.context()
        context["extension"] = self.sub_version
        context["sub_version"] = self.sub_version
        return context


@dataclasses.dataclass
class GradleSettings:
    root_project_name: str | None
    includes: list[str]

    def __post_init__(self):
        assert self.root_project_name is not None
        assert self.includes is not None


def find_poms():
    for root, dirs, files in os.walk("./", topdown=True):
        for filename in files:
            if filename in ["pom.xml"]:
                yield os.path.join(root, filename)


def find_properties():
    for root, dirs, files in os.walk("./", topdown=True):
        for filename in files:
            if filename in ["gradle.properties", "release.properties"]:
                yield os.path.join(root, filename)


def guess_repo(version: str):
    if version is None:
        return None
    if "SNAPSHOT" in version.upper():
        return "snapshots"
    else:
        return "releases"


def parse_gradle_settings(data: str) -> GradleSettings | None:
    root_project_name = None
    includes = []
    if data is None:
        return None
    lines = data.split("\n")
    for line in lines:
        line = re.sub("#.*", "", line)
        line = line.strip()
        if len(line) == 0:
            continue
        if line.startswith("rootProject.name"):
            split = line.split("=", 1)
            if len(split) > 1:
                value = split[1].strip()
                try:
                    value = json.loads(value)
                except Exception:
                    try:
                        value = ast.literal_eval(value)
                    except Exception:
                        pass
                root_project_name = value
                continue
        if line.startswith("include "):
            # include 'signon-service-dto', 'signon-service'
            parts = line.split(" ", 1)
            if len(parts) > 1:
                value = parts[1:][0]
                try:
                    value = json.loads(value)
                except Exception:
                    try:
                        value = ast.literal_eval(value)
                    except Exception:
                        pass
                if isinstance(value, tuple):
                    value = list(value)
                if isinstance(value, str):
                    value = [value]
                value = [x.strip(":") for x in value]
                includes.extend(value)

    return GradleSettings(root_project_name, includes)


def read_gradle_settings() -> GradleSettings | None:
    filename = "./settings.gradle"
    if os.path.exists(filename):
        with open(filename, encoding="utf-8") as f:
            return parse_gradle_settings(f.read())
    return None


def text_of(element: ElementTree.Element, path: str) -> str | None:
    maybe = element.find(path, POM_NAMESPACE)
    if maybe is not None:
        return maybe.text.strip()
    else:
        return None


class Main(cmd.Main):
    def __init__(self):
        super().__init__()
        self.parser.add_argument(
            "--version",
            dest="version",
            default=None,
            help="Force this version",
        )
        self.parser.add_argument(
            "--group",
            dest="group_id",
            default=None,
            help="Force this group",
        )
        self.parser.add_argument(
            "--artifact",
            dest="artifact",
            default=None,
            help="Force this artifact",
        )
        self.parser.add_argument(
            "--extension",
            dest="extension",
            default=None,
            help="Force this artifact",
        )
        self.parser.add_argument(
            "--sonatype-base-url",
            dest="sonatype_base_url",
            default=os.environ.get("SONATYPE_BASE_URL"),
        )
        self.parser.add_argument(
            "--thorough", dest="thorough", action="store_true", default=False
        )
        self.parser.add_argument(
            "--nexus-repo",
            dest="nexus_repo",
            choices=list(REPOS.keys()),
            default=None,
        )
        self.configs: dict[str, dict] = dict()
        self.poms: dict[str, ElementTree.Element] = dict()
        self.gets = dict()
        self.repos: dict[str, Repo] = dict()

    def get(self, url) -> requests.Response:
        if url not in self.gets:
            try:
                self.gets[url] = requests.get(url)
                if self.gets[url].status_code >= 400:
                    logger.warning("GET %s %s", self.gets[url].status_code, url)
                else:
                    logger.info("GET %s %s", self.gets[url].status_code, url)
            except Exception:
                logger.exception("Error fetching %s", url)
        return self.gets.get(url)

    def load_properties_into_configs(self, filename):
        try:
            with open(filename, "rb") as config_file:
                config = jproperties.Properties()
                config.load(config_file)
                self.configs[filename] = dict()
                for item in config.items():
                    self.configs[filename][item[0]] = item[1].data
        except Exception:
            logger.exception("Oopies")

    def load_pom_xml_into_configs(self, filename):
        try:
            with open(filename, "rb") as config_file:
                tree = ElementTree.parse(config_file)
                root = tree.getroot()
                self.poms[filename] = root
        except Exception:
            logger.exception("Oopies")

    def main(self):
        super().main()

        self.expected_extensions: set[str]
        if self.args.extension:
            self.expected_extensions = {self.args.extension}
        else:
            self.expected_extensions = {"pom", "jar"}

        sonatype_path = f"{self.args.sonatype_base_url}/nexus/content"
        for nexus_repo_name, nexus_repo_path in REPOS.items():
            self.repos[nexus_repo_name] = Repo(sonatype_path, nexus_repo_path, nexus_repo_name)

        for path in find_properties():
            self.load_properties_into_configs(path)
        for path in find_poms():
            self.load_pom_xml_into_configs(path)
        gradle_settings = read_gradle_settings()

        artifact_versions: set[ArtifactVersion] = set()

        properties = {}
        sonatype_artifact_versions: set[ArtifactVersion] = set()

        if self.configs:
            properties.update(self.configs.get("./gradle.properties") or {})
            release_properties = {}
            release_properties.update(properties)
            release_properties.update(self.configs.get("./release.properties") or {})
            base_artifact_id = self.get_artifact_id(properties, release_properties)
            base_group = self.get_group(properties, release_properties)
            if base_group and base_artifact_id:
                assert base_artifact_id is not None
                artifact_versions.update(
                    self.get_artifact_versions_from_properties(
                        base_group, base_artifact_id, properties, release_properties
                    )
                )
                sonatype_artifact_versions.update(
                    self.get_artifact_versions_from_sonatype(base_group, base_artifact_id)
                )

            if gradle_settings:
                includes = gradle_settings.includes or []
            else:
                includes = []
            if includes:
                for include in includes:
                    include_properties = {}
                    include_properties.update(properties)
                    include_properties.update(
                        self.configs.get(f"./{include}/gradle.properties") or {}
                    )
                    include_release_properties = {}
                    include_release_properties.update(include_properties)
                    include_release_properties.update(release_properties)
                    include_release_properties.update(
                        self.configs.get(f"./{include}/release.properties") or {}
                    )

                    include_group = self.get_group(
                        include_properties, include_release_properties
                    )
                    include_artifact_id = self.get_artifact_id(
                        include_properties, include_release_properties
                    )
                    if include_group and include_artifact_id:
                        sonatype_artifact_versions.update(
                            self.get_artifact_versions_from_sonatype(
                                include_group, include_artifact_id
                            )
                        )

                        artifact_versions.update(
                            self.get_artifact_versions_from_properties(
                                include_group,
                                include_artifact_id,
                                include_properties,
                                include_release_properties,
                            )
                    )
        elif self.poms:
            artifact_versions.update(
                self.get_artifact_versions_from_poms()
            )
            got_metadata: set[str] = set()
            for artifact_version in artifact_versions:
                artifact_group = artifact_version.repo_artifact.group
                artifact_id = artifact_version.repo_artifact.artifact_id
                assert artifact_id is not None
                artifact_stub = f"{artifact_group.group_id}:{artifact_id}"
                if artifact_stub not in got_metadata:
                    sonatype_artifact_versions.update(
                        self.get_artifact_versions_from_sonatype(
                            artifact_group, artifact_id
                        )
                    )
                    got_metadata.add(artifact_stub)

        if self.args.thorough:
            artifact_versions.update(sonatype_artifact_versions)

        artifact_version_extensions: set[ArtifactVersionExtension] = set()
        for artifact_version in sorted(artifact_versions, key=lambda x: x.url):
            with logging_context(**artifact_version.context()):
                extension: str | None = self.args.extension
                if extension is not None:
                    artifact_version_extension = ArtifactVersionExtension(
                        artifact_version, extension, artifact_version.version
                    )
                    artifact_version_extensions.add(artifact_version_extension)
                if artifact_version.repo_artifact.nexus_repo.name in ("releases", "public"):
                    for extension in self.expected_extensions:
                        artifact_sub_version = ArtifactVersionExtension(
                            artifact_version, extension, artifact_version.version
                        )
                        artifact_version_extensions.add(artifact_sub_version)
                if artifact_version.repo_artifact.nexus_repo.name == "snapshots":
                    artifact_version_extensions.update(self.get_artifact_version_extensions(artifact_version))

        for artifact_version_extension in artifact_version_extensions:
            self.get(artifact_version_extension.sha_url)

    def get_artifact_version_extensions(self, artifact_version: ArtifactVersion) -> set[ArtifactVersionExtension]:
        artifact_version_extensions: set[ArtifactVersionExtension] = set()
        metadata_sha_response = self.get(artifact_version.metadata_sha_url)
        if metadata_sha_response is not None and metadata_sha_response.status_code == 200:
            artifact_version_response = self.get(artifact_version.metadata_url)
            if artifact_version_response is not None and artifact_version_response.status_code == 200:
                artifact_version_content = artifact_version_response.content
                try:
                    tree = ElementTree.fromstring(artifact_version_content)
                except Exception:
                    logger.warning(
                        "Could not load %s", artifact_version.metadata_url
                    )
                    return artifact_version_extensions
                versioning = tree.find("versioning")
                if versioning is None or not len(versioning):
                    return artifact_version_extensions

                snapshot_versions = versioning.find("snapshotVersions")
                if snapshot_versions is not None and len(snapshot_versions):
                    for snapshot_version in snapshot_versions.iter(
                        "snapshotVersion"
                    ):
                        extension = snapshot_version.find("extension").text
                        if (
                            self.args.thorough
                            or self.args.extension is None
                            or self.args.extension == extension
                        ):
                            self.expected_extensions.add(extension)
                            sub_version = snapshot_version.find("value").text
                            artifact_sub_version = ArtifactVersionExtension(
                                artifact_version, extension, sub_version
                            )
                            artifact_version_extensions.add(artifact_sub_version)
        return artifact_version_extensions

    def get_artifact_versions_from_properties(
        self, group: Group, artifact_id: str, properties, release_properties
    ) -> list[ArtifactVersion]:
        with logging_context(group_id=group.group_id, artifact_id=artifact_id):
            if not group or not artifact_id:
                logger.debug(f"Skipping {group=} {artifact_id=}")
                return []

            artifact_versions = []
            for version in self.get_versions(properties, release_properties):
                if version is None:
                    continue
                guessed_repo = self.guess_repo(version)
                forced_repo = self.args.nexus_repo
                if forced_repo is None or forced_repo == guessed_repo:
                    repo = self.repos.get(guessed_repo)
                else:
                    repo = self.repos.get(forced_repo)
                repo_artifact = RepoArtifact(repo, group, artifact_id)
                artifact_version = ArtifactVersion(repo_artifact, version)
                artifact_versions.append(artifact_version)
            return artifact_versions

    def get_artifact_versions_from_poms(self) -> set[ArtifactVersion]:
        artifact_versions: set[ArtifactVersion] = set()
        for config_path, config in self.poms.items():
            artifact_id = text_of(config, "pom:artifactId")
            version = text_of(config, "pom:version")
            group_id = text_of(config, "pom:groupId")

            parent_tag = config.find("pom:parent", POM_NAMESPACE)
            if parent_tag is not None:
                if version is None:
                    version = text_of(parent_tag, "pom:version")
                if group_id is None:
                    group_id = text_of(parent_tag, "pom:groupId")
            if group_id is not None and version is not None and artifact_id is not None:
                guessed_repo = self.guess_repo(version)
                forced_repo = self.args.nexus_repo
                if forced_repo is None or forced_repo == guessed_repo:
                    repo = self.repos.get(guessed_repo)
                else:
                    repo = self.repos.get(forced_repo)
                repo_artifact = RepoArtifact(repo, Group(group_id), artifact_id)
                artifact_version = ArtifactVersion(repo_artifact, version)
                artifact_versions.add(artifact_version)
        return artifact_versions

    def get_artifact_id(self, properties, release_properties) -> str | None:
        args_artifact_id = self.args.artifact
        properties_artifact_id = properties.get("artifactId")
        release_properties_artifact_id = release_properties.get("artifactId")
        for artifact_id in (
            args_artifact_id,
            properties_artifact_id,
            release_properties_artifact_id,
        ):
            if artifact_id is not None:
                return artifact_id
        logger.debug("Did not find artifact_id")
        return None

    def get_group(self, properties, release_properties) -> Group | None:
        group_id = self.args.group_id
        if group_id is not None:
            return Group(group_id)
        for p in properties, release_properties:
            group_id = p.get("groupId")
            if group_id is not None:
                return Group(group_id)
        logger.debug("Did not find group")
        return None

    def get_versions(self, properties, release_properties) -> list[str]:
        args_version = self.args.version
        if args_version is not None:
            return [args_version]
        properties_version = properties.get("version")
        release_version = release_properties.get("version")
        versions = list(
            set(x for x in [properties_version, release_version] if x is not None)
        )
        if not versions and not self.args.thorough:
            raise ValueError(
                "Could not find versions in properties files (try --thorough or specifying a version directly"
            )
        return versions

    def guess_repo(self, version) -> str:
        if version is None:
            raise ValueError("Cannot guess repo for none version")
        if "SNAPSHOT" in version.upper():
            return "snapshots"
        else:
            return "releases"

    def get_artifact_versions_from_sonatype(
        self, group: Group, artifact_id: str
    ) -> set[ArtifactVersion]:
        assert artifact_id is not None
        with logging_context(artifact_id=artifact_id, **group.context()):
            if self.args.nexus_repo:
                nexus_repos = [self.args.nexus_repo]
            else:
                nexus_repos = list(REPOS.keys())
            artifact_versions: set[ArtifactVersion] = set()
            for nexus_repo in nexus_repos:
                repo = self.repos[nexus_repo]
                with logging_context(**repo.context()):
                    repo_artifact = RepoArtifact(repo, group, artifact_id)
                    sha_response = self.get(repo_artifact.metadata_sha_url)
                    if sha_response is None or sha_response.status_code != 200:
                        logger.debug("No metadata sha available.")
                        continue

                    artifact_response = self.get(repo_artifact.metadata_url)
                    if artifact_response.status_code < 400:
                        artifact_content = artifact_response.content
                        try:
                            tree = ElementTree.fromstring(artifact_content)
                            versioning = tree.find("versioning")
                            version = versioning.find("latest").text.strip()
                            artifact_version = ArtifactVersion(repo_artifact, version)
                            artifact_versions.add(artifact_version)
                            for version_tag in versioning.iter("version"):
                                version_tag_value = version_tag.text.strip()
                                if version_tag_value and version_tag != version:
                                    artifact_version = ArtifactVersion(
                                        repo_artifact, version_tag_value
                                    )
                                    artifact_versions.add(artifact_version)
                            versions = versioning.find("versions")
                            if versions is not None:
                                for version_tag in versions.iter("version"):
                                    if version_tag is not None:
                                        version_tag_value = version_tag.text.strip()
                                        if version_tag_value and version_tag != version:
                                            artifact_version = ArtifactVersion(
                                                repo_artifact, version_tag_value
                                            )
                                            artifact_versions.add(artifact_version)

                        except Exception:
                            logger.error("Could not parse xml")
        return artifact_versions


if __name__ == "__main__":
    Main().main()
